#+TITLE: My init as an org file
#+PROPERTY: header-args :tangle config.el
#+OPTIONS: toc:nil
#+auto_tangle: t

* Helpers

  There are a number of helper functions that we'll need through the
  rest of this. We'll just define them up here.

** load-if-exists

   This is just a nice function to load a file if it exists, but just
   print a message rather than an error if it doesn't. This is handy
   for things like loading specific local config that you don't want
   to go into github or be shared such as erc nicks, passwords, blog
   rolls, etc.

   #+BEGIN_SRC emacs-lisp
     (defun load-if-exists (file)
       (if (file-exists-p file)
           (progn
             (load file)
             (message (format "Loading file: %s" file)))
         (message (format "No %s file. So not loading one." file))))
   #+END_SRC

** Fix bracket and quote mismatches in src blocks

   #+BEGIN_SRC emacs-lisp
     (defun org-mode-gt-lt-fix ()
       "Remove gt and lt from syntax entry to prevent unbalanced parens"
       (modify-syntax-entry ?< ".")
       (modify-syntax-entry ?> "."))
     (add-hook 'org-mode-hook 'org-mode-gt-lt-fix)
     (org-mode-gt-lt-fix)
   #+END_SRC

** Add in vc-use-package

   Install vc-use-package so I can install from Git.

   #+begin_src emacs-lisp :tangle yes
     (unless (package-installed-p 'vc-use-package)
       (package-vc-install "https://github.com/slotThe/vc-use-package"))
     (require 'vc-use-package)
   #+end_src

* Local Config

** custom.el

   custom.el is great for configuring things through that "gui" in
   emacs, but it is a real pain when it drops junk in your [[../init.el][init.el]] and
   messes up your pretty config and git history and is stuff that you
   don't want to leak out on to github. You can change the location of
   this file though and I like to do this.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (concat user-emacs-directory "local/custom.el"))
     (load-if-exists custom-file)
   #+END_SRC

* Globals

** passwords and encrypted things

   It is good to store your passwords and things in an encrypted
   file. I call mine mellon, because you can only read it if you are
   my friend and have the passphrase.

   This does mean that every time you use it you have to give the
   passphrase, but it does mean that you can keep all your passwords
   for things like erc and stuff in a file reasonably safely (though
   it will be in memory when emacs is running, so it isn't completely
   secure).

   #+BEGIN_SRC emacs-lisp
     (load-if-exists (concat user-emacs-directory "local/mellon.el.gpg"))
   #+END_SRC

** Set initial framesize

   #+BEGIN_SRC emacs-lisp
     (setq initial-frame-alist '((top . 0) (left . 0) (width . 140)
                                 (height . 45)))
   #+END_SRC


** Auto indent on newline

   Again something lifted from
   www.masteringemacs.org/article/beginners-guide-to-emacs

   #+BEGIN_SRC emacs-lisp
     (define-key global-map (kbd "RET") 'newline-and-indent)
   #+END_SRC

** diminish

   As we add lots of useful minor-modes the mode line can get a bit
   unwieldy. diminish-mode helps us with that. We'll set it up here
   and use it in various places throughout the setup.

   #+BEGIN_SRC emacs-lisp
     (use-package diminish
       :ensure t)
   #+END_SRC

** Tabs are Evil

   I mean, not like evil-mode is good for vi users who want to use
   emacs, which is fine, and obviously not like a truly evil thing,
   but you know, not what I want. Hey, I can use hyperbole in my
   org-mode files if I want to.

   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+END_SRC

** Multiple Cursors

   This is a replacement for the iedit that I used to have. Neale
   Swinnerton was the one who showed this to Bruce and it looked really
   cool.

   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :config
       (multiple-cursors-mode 1)
       (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
       (global-set-key (kbd "C->") 'mc/mark-next-like-this)
       (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
       (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this))

   #+END_SRC

** Remap M-i to back-to-indentation

   I've got used to back-to-indentation mapped to M-i

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-i") 'back-to-indentation)
   #+END_SRC

** loccur mode

   loccur mode hides all lines except those containing matches

   #+BEGIN_SRC emacs-lisp
     (use-package loccur :ensure t)
     (global-set-key (kbd "C-M-o") 'loccur-current)
     (global-set-key (kbd "C-M-S-o") 'loccur)
   #+END_SRC

** Tooltips in echo area

   Got this from www.masteringemacs.org

   #+BEGIN_SRC emacs-lisp
     (tooltip-mode -1)
     (setq tooltip-use-echo-area nil)
   #+END_SRC

** Y and N prompts

   Change the yes and no prompts to y and n

   #+BEGIN_SRC emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Time in status

   #+BEGIN_SRC emacs-lisp
     (display-time-mode 1)
   #+END_SRC

** Key chord mode

   #+BEGIN_SRC emacs-lisp
     (use-package key-chord
       :ensure t
       :config
       (setq key-chord-two-keys-delay 0.1)
       (setq key-chord-one-key-delay 0.2)
       (key-chord-mode 1))
   #+END_SRC

** window-number-super mode

   Window number mode shows the number of the window in the
   mini-buffer. Window number meta mode enables selecting a window by
   using META-n where n is the windows number.

   #+BEGIN_SRC emacs-lisp
     (use-package window-number
       :ensure t)
     (window-number-mode t)
     (window-number-meta-mode t)
   #+END_SRC

** shrink and enlarge windows

   On large screens where there are lots of windows in a frame we'll
   often want to shrink or grow individual windows. It would be handy
   to have easier keys for this.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "s-=") 'shrink-window)
     (global-set-key (kbd "s-+") 'enlarge-window)
   #+END_SRC

** Use hide show minor mode everywhere

   #+BEGIN_SRC emacs-lisp
     (add-hook 'prog-mode-hook 'hs-minor-mode)
   #+END_SRC

** Set regex syntax to string

   Set the regex syntax to string to prevent double escaping of regex expressions.

   #+begin_src emacs-lisp
     (setq reb-re-syntax 'string)
   #+end_src

** Set select help window

   I want to select the help window so I have my cursor in the right place to press q to quit.

   #+begin_src emacs-lisp :tangle yes
     (setq help-window-select t)
   #+end_src

* Macintosh Specific Setup
** command key as meta

   Function to remap meta and super keys for builtin mac keyboard.

   #+BEGIN_SRC emacs-lisp
     (defun macbook-keyboard-remap ()
       "Remap meta and super to suit the builtin Macbook keyboard"
       (interactive)
       (setq mac-command-modifier 'meta)
       (setq mac-option-modifier 'super))
   #+END_SRC

   Function to remap meta and super keys for PC keyboard.

   #+BEGIN_SRC emacs-lisp
     (defun pc-keyboard-remap ()
       "Remap meta and super to suit an external PC style keyboard"
       (interactive)
       (setq mac-command-modifier 'super)
       (setq mac-option-modifier 'meta))
   #+END_SRC

* Make it Pretty

** color themes

*** custom-theme-directory

    Themes seem to be quite picky about where they live. They require
    custom-theme-directory to be set. By default this is the same as
    user-emacs-directory, which is usually ~/.emacs.d. I'd like to
    keep them separate if possible. I learned this one by reading
    some of [[https://github.com/sw1nn/dotfiles][Neale Swinnerton's dotfiles]].

    #+BEGIN_SRC emacs-lisp
      (setq custom-theme-directory (concat user-emacs-directory "themes"))
    #+END_SRC

*** VSCode dark theme

    #+BEGIN_SRC emacs-lisp
      (use-package vscode-dark-plus-theme
        :ensure t)
      (enable-theme 'vscode-dark-plus)
    #+END_SRC

** Default font height

   #+BEGIN_SRC emacs-lisp
     (set-face-attribute 'default nil :height 140)
   #+END_SRC


** Default font scale

   #+BEGIN_SRC emacs-lisp
     (use-package default-text-scale
       :ensure t
       :config
       (setq default-text-scale-mode t))
   #+END_SRC
** bars, menus and numbers

   I like no scroll bars, no toolbars and line and column numbers in
   the mode-line.

   #+BEGIN_SRC emacs-lisp
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     (line-number-mode -1)
     (column-number-mode 1)
     (menu-bar-mode -1)
     (setq display-line-numbers-type 'absolute)
     ;; (global-display-line-numbers-mode)
   #+END_SRC

** All the icons

   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons
       :ensure t)
   #+END_SRC

* Tool Configuration
** Dashboard

   #+BEGIN_SRC emacs-lisp
     (use-package dashboard :ensure t)
     (dashboard-setup-startup-hook)
     (setq dashboard-items '((recents  . 10)
                             (bookmarks . 5)
                             (projects . 5)
                             (agenda . 5)
                             (registers . 5)))
     (setq dashboard-projects-switch-function 'projectile-persp-switch-project)
     (setq dashboard-week-agenda nil)
     (setq dashboard-filter-agenda-entry 'dashboard-filter-agenda-by-time)
     (setq dashboard-agenda-sort-strategy '(time-up))
     (setq dashboard-set-heading-icons t)
     (setq dashboard-set-file-icons t)
     (setq dashboard-agenda-prefix-format " %-12:c%?-12t% s")
     (setq dashboard-set-navigator t)
     ;; Format: "(icon title help action face prefix suffix)"
     (setq dashboard-navigator-buttons
           `(;; line1
             ((,(all-the-icons-octicon "mark-github" :height 1.1 :v-adjust 0.0)
               "GitHub Homepage"
               "Browse GH Homepage"
               (lambda (&rest _) (browse-url "https://github.com/chrishowejones")))
              ("?" "" "?/h" #'show-help nil "<" ">"))
             ;; line 2
             ((,(all-the-icons-faicon "linkedin" :height 1.1 :v-adjust 0.0)
               "Linkedin"
               ""
               (lambda (&rest _) (browse-url "https://www.linkedin.com/in/chrishowejones/"))))))
     (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
     ;; Remap Open Dashboard
     (defun new-dashboard ()
       "Jump to the dashboard buffer, if doesn't exists create one."
       (interactive)
       (switch-to-buffer dashboard-buffer-name)
       (dashboard-mode)
       (dashboard-insert-startupify-lists)
       (dashboard-refresh-buffer))
     (global-set-key (kbd "<f1>") 'new-dashboard)
   #+END_SRC

*** Startup Screen

    I'd also like to skip the startup screen and go straight to
    the *dashboard* buffer.

    #+BEGIN_SRC emacs-lisp
      (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
      (setq inhibit-startup-screen t)
    #+END_SRC


** Recent file mode

   Add in recentf mode.

   #+begin_src emacs-lisp
     (recentf-mode t)
     (setq recentf-max-menu-items 25)
     (setq recentf-max-saved-items 25)
   #+end_src

** Hydra

   Add in Hydra

   #+begin_src emacs-lisp
     (use-package hydra
       :ensure t)
   #+end_src

** ediff

   ediff is my favourite way of comparing files, directories, versions
   and buffers in emacs. It does annoy me the way it brings up a new
   frame though. I'd much rather keep everything in the same frame
   even when I'm on a windowing system.

   #+BEGIN_SRC emacs-lisp
     (setq ediff-window-setup-function 'ediff-setup-windows-plain)
   #+END_SRC

** company

   Complete Anything or [[http://company-mode.github.io/][company-mode]] seems to be the way to complete
   things in emacs now.

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :init
       (add-hook 'after-init-hook 'global-company-mode)
       (diminish 'company-mode "CA")
       (global-set-key (kbd "C-M-i") 'company-complete)
       (setq company-tooltip-flip-when-above t)
       (setq company-minimum-prefix-length 1)               ; WARNING, probably you will get perfomance issue if min len is 0!
       (setq company-tooltip-limit 20)                      ; bigger popup window
       (setq company-tooltip-align-annotations 't)          ; align annotations to the right tooltip border
       (setq company-idle-delay 0.3)                        ; decrease delay before autocompletion popup shows
       (setq company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
       (global-set-key (kbd "C-c /") 'company-files)        ; Force complete file names on "C-c /" key
       )
   #+END_SRC

** Vertico for completion

   Use vertico for completion.

   #+begin_src emacs-lisp
     (use-package vertico
       :ensure t
       :pin melpa-stable
       :init
       (vertico-mode)
       ;; Enable vertico-multiform
       (vertico-multiform-mode)

       ;; Configure the display per completion category.
       ;; Use the grid display for files and a buffer
       ;; for the consult-grep commands.
       (setq vertico-multiform-categories
             '((file grid)))
       (setq vertico-multiform-commands
             '((consult-grep buffer)
               (consult-ripgrep buffer)
               (consult-imenu buffer)
               (crux-recentf-find-file grid)))
       ;; Use `consult-completion-in-region' if Vertico is enabled.
       ;; Otherwise use the default `completion--in-region' function.
       (setq completion-in-region-function
             (lambda (&rest args)
               (apply (if vertico-mode
                          #'consult-completion-in-region
                        #'completion--in-region)
                      args))))
   #+end_src

** Orderless

   Use orderless for completion pattern matching of chars separated by
   spaces that match in any order.

   #+begin_src emacs-lisp
     (use-package orderless
       :ensure t
       :custom
       (completion-styles '(basic orderless))
       (completion-category-overrides
        '((buffer (styles basic partial-completion))
          (command (styles basic partial-completion)))))
     (setq read-file-name-completion-ignore-case t
           read-buffer-completion-ignore-case t
           completion-ignore-case t)
   #+end_src

** Embark

   Use Embark to choose an action based on what is near at point.

   #+begin_src emacs-lisp :tangle yes
     (use-package embark
       :ensure t

       :bind
       (("C-." . embark-act)         ;; pick some comfortable binding
        ("C-;" . embark-dwim)        ;; good alternative: M-.
        ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

       :init

       ;; Optionally replace the key help with a completing-read interface
       (setq prefix-help-command #'embark-prefix-help-command)

       ;; Show the Embark target at point via Eldoc. You may adjust the
       ;; Eldoc strategy, if you want to see the documentation from
       ;; multiple providers. Beware that using this can be a little
       ;; jarring since the message shown in the minibuffer can be more
       ;; than one line, causing the modeline to move up and down:

       ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
       ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

       :config

       ;; Hide the mode line of the Embark live/completions buffers
       (add-to-list 'display-buffer-alist
                    '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                      nil
                      (window-parameters (mode-line-format . none)))))
   #+end_src

** Consult

   Use consult for search and navigation commands.

   #+begin_src emacs-lisp
     (use-package consult
       :ensure t
       ;; Replace bindings. Lazily loaded due by use-package.
       :bind  (;; C-c bindings in mode-specific-map
               ("C-c M-x" . consult-mode-command)
               ("C-c h" . consult-history)
               ("C-c k" . consult-kmacro)
               ("C-c m" . consult-man)
               ([remap Info-search] . consult-info)
               ;; C-x bindings in ctl-x-map
               ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
               ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
               ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
               ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
               ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
               ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
               ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
               ;; Custom M-# bindings for fast register access
               ("M-#" . consult-register-load)
               ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
               ("C-M-#" . consult-register)
               ;; Other custom bindings
               ("C-c i" . consult-info)
               ("M-y" . consult-yank-pop)                ;; orig. yank-pop
               ;; M-g bindings in goto-map
               ("M-g e" . consult-compile-error)
               ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
               ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
               ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
               ("M-g m" . consult-mark)
               ("M-g k" . consult-global-mark)
               ("M-g i" . consult-imenu)
               ("M-g I" . consult-imenu-multi)
               ;; M-s bindings in search-map
               ("C-c s d" . consult-find)                  ;; Alternative: consult-fd
               ("C-c s c" . consult-locate)
               ("C-c s g" . consult-grep)
               ("C-c s G" . consult-git-grep)
               ("C-c s r" . consult-ripgrep)
               ("C-s"   . consult-line)
               ("C-c s L" . consult-line-multi)
               ("C-c s k" . consult-keep-lines)
               ("C-c s u" . consult-focus-lines)
               ;; Isearch integration
               ("M-s e" . consult-isearch-history)
               :map isearch-mode-map
               ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
               ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
               ;; ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
               ;; ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
               ;; Minibuffer history
               :map minibuffer-local-map
               ("M-s" . consult-history)                 ;; orig. next-matching-history-element
               ("M-r" . consult-history))                ;; orig. previous-matching-history-element

       ;; Enable automatic preview at point in the *Completions* buffer. This is
       ;; relevant when you use the default completion UI.
       :hook (completion-list-mode . consult-preview-at-point-mode)

       ;; The :init configuration is always executed (Not lazy)
       :init

       ;; Optionally configure the register formatting. This improves the register
       ;; preview for consult-register, consult-register-load,
       ;; consult-register-store and the Emacs built-ins.
       (setq register-preview-delay 0.5
             register-preview-function #'consult-register-format)

       ;; Optionally tweak the register preview window.
       ;; This adds thin lines, sorting and hides the mode line of the window.
       (advice-add #'register-preview :override #'consult-register-window)

       ;; Use Consult to select xref locations with preview
       (setq xref-show-xrefs-function #'consult-xref
             xref-show-definitions-function #'consult-xref)
       ;; Configure other variables and modes in the :config section,
       ;; after lazily loading the package.
       :config

       ;; Optionally configure preview. The default value
       ;; is 'any, such that any key triggers the preview.
       ;; (setq consult-preview-key 'any)
       ;; (setq consult-preview-key "M-.")
       ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
       ;; For some commands and buffer sources it is useful to configure the
       ;; :preview-key on a per-command basis using the consult-customize macro.
       (consult-customize
        consult-theme :preview-key '(:debounce 0.2 any)
        consult-ripgrep consult-git-grep consult-grep
        consult-bookmark consult-recent-file consult-xref
        consult--source-bookmark consult--source-file-register
        consult--source-recent-file consult--source-project-recent-file
        ;; :preview-key "M-."
        :preview-key '(:debounce 0.4 any))

       ;; Optionally configure the narrowing key.
       ;; Both "<" and C-+ work reasonably well.
       (setq consult-narrow-key "<")

       ;; Optionally make narrowing help available in the minibuffer.
       ;; You may want to use embark-prefix-help-command or which-key instead.
       ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

       ;; By default consult-project-function uses project-root from project.el.
       ;; Optionally configure a different project root function.
       ;;;; 1. project.el (the default)
       ;; (setq consult-project-function #'consult--default-project--function)
       ;;;; 2. vc.el (vc-root-dir)
       ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
       ;;;; 3. locate-dominating-file
       ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
       ;; 4. projectile.el (projectile-project-root)
       (autoload 'projectile-project-root "projectile")
       (setq consult-project-function (lambda (_) (projectile-project-root)))
       ;;;; 5. No project support
       ;; (setq consult-project-function nil)

       )
   #+end_src

   Add in Embark Consult config.

   #+begin_src emacs-lisp :tangle yes
     ;; Consult users will also want the embark-consult package.
     (use-package embark-consult
       :ensure t ; only need to install it, embark loads it after consult if found
       :hook
       (embark-collect-mode . consult-preview-at-point-mode))
   #+end_src

** avy-mode

   This is supposed to be a replacement for ace-jump-mode so thought
   I'd give it a whirl.

   #+BEGIN_SRC emacs-lisp
     (use-package avy :ensure t)
     (avy-setup-default)
     (global-set-key (kbd "C-c j") 'avy-goto-word-or-subword-1)
     (global-set-key (kbd "M-g g") 'avy-goto-line)
     (global-set-key (kbd "C-c k") 'avy-kill-region)
     (global-set-key (kbd "C-c w") 'avy-goto-char-timer)
     (global-set-key (kbd "C-c c") 'avy-goto-char)
   #+END_SRC

** Marginalia

   Add marginalia to display annotations. Used in conjunction with Vertico.

   #+begin_src emacs-lisp
     ;; Enable rich annotations using the Marginalia package
     (use-package marginalia
       :ensure t
       ;; Bind marginalia-cycle locally in the minibuffer.  To make the binding
       ;; available in the *Completions* buffer, add it to the
       ;; completion-list-mode-map.
       :bind (:map minibuffer-local-map
                   ("M-A" . marginalia-cycle))

       ;; The :init section is always executed.
       :init

       ;; Marginalia must be activated in the :init section of use-package such that
       ;; the mode gets enabled right away. Note that this forces loading the
       ;; package.
       (marginalia-mode))
   #+end_src

** Treemacs

   #+BEGIN_SRC emacs-lisp
     (use-package treemacs
       :ensure t)
     (use-package treemacs-magit
       :after treemacs magit
       :ensure t)
     (use-package treemacs-projectile
       :after treemacs projectile
       :ensure t)

     (use-package treemacs-icons-dired
       :after treemacs dired
       :ensure t
       :config (treemacs-icons-dired-mode))
   #+END_SRC

** Command log mode

   Add in command log mode.

   #+begin_src emacs-lisp
     (use-package command-log-mode
       :ensure t
       :config
       (command-log-mode t)
       :bind
       ("C-c l" . clm/toggle-command-log-buffer))
   #+end_src

* directories, navigation, searching, movement
** paredit-mode

   paredit-mode is a strange one. When you first use it, you will
   hate it. You'll hate the way it won't let you do the things
   you *think* you want to do. Once you get used to it though you
   wonder how you ever did any programming without it.

   #+BEGIN_SRC emacs-lisp
     (use-package paredit
       :ensure t
       :config
       (diminish 'paredit-mode "()")
       :hook
       prog-mode)
   #+END_SRC

** paredit spaces for non s-expr langs

   Need to stop insertion of spaces between symbols and parens for
   non s-expr langs

   #+BEGIN_SRC emacs-lisp
     (defun my-paredit-nonlisp ()
       "Turn on paredit mode for non-lisps."
       (interactive)
       (set (make-local-variable 'paredit-space-for-delimiter-predicates)
            '((lambda (endp delimiter) nil)))
       (electric-pair-mode t)
       (paredit-mode t))
   #+END_SRC

   I *always* want my parens to match (except in text modes and some
   non-lisp programming modes).

   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook 'my-paredit-nonlisp)
     (add-hook 'js2-mode-hook 'my-paredit-nonlisp)
     (add-hook 'typescript-mode-hook 'my-paredit-nonlisp)
     (add-hook 'java-mode-hook 'my-paredit-nonlisp)
   #+END_SRC

** dired

   dired can do lots of things. I'm pretty basic in my use. I do like
   to have the file listings use human friendly numbers though.

   #+BEGIN_SRC emacs-lisp
     (require 'dired)
     (setq dired-listing-switches "-alh")
   #+END_SRC

** Mouse Avoidance

   I don't want that pesky mouse hanging around in the middle of the
   screen while I'm typing.

   #+BEGIN_SRC emacs-lisp
     (mouse-avoidance-mode 'banish)
   #+END_SRC

** window and buffer tweaking

*** buffer movement

    Sometimes the problem isn't that you want to move the cursor to a
    particular window, but you want to move a buffer. buffer-move lets
    you do that.

    #+BEGIN_SRC emacs-lisp
      (use-package buffer-move
        :ensure t
        :config
        (global-set-key (kbd "<s-up>")     'buf-move-up)
        (global-set-key (kbd "<s-down>")   'buf-move-down)
        (global-set-key (kbd "<s-left>")   'buf-move-left)
        (global-set-key (kbd "<s-right>")  'buf-move-right))
    #+END_SRC

** git

*** magit

    magit is a *fantastic* mode for dealing with git.

    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :ensure t)
    #+END_SRC

    I use magit-status a lot. So let's bind it to C-x g.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-x g") 'magit-status)
    #+END_SRC

*** git-gutter-mode+

    It is really nice having +/= in the gutter. I like it more than
    having line numbers and thus I've dumped linum-mode.

    #+BEGIN_SRC emacs-lisp
      (use-package git-gutter-fringe+
        :ensure t
        :config
        (global-git-gutter+-mode t))
    #+END_SRC

    It is also quite nice to be able to navigate a file by he git
    hunks. It makes it a bit easier to see what has changed since the
    last time in the context of the whole file.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "s-n") 'git-gutter+-next-hunk)
      (global-set-key (kbd "s-p") 'git-gutter+-previous-hunk)
    #+END_SRC

    We can diminish the size of GitGutter in the mode-line

    #+BEGIN_SRC emacs-lisp
      (diminish 'git-gutter+-mode)
    #+END_SRC

*** gitlink

    #+begin_src emacs-lisp
      (use-package git-link
        :ensure t
        :config
        (global-set-key (kbd "C-c g l") 'git-link)
        (setq git-link-open-in-browser t))
    #+end_src

*** Git timemachine

    Git timemachine can be used to rewind and fast forward through
    time for any file under Git version control.

    #+BEGIN_SRC emacs-lisp
      (use-package git-timemachine
        :ensure t)
    #+END_SRC

*** github-browse-file

    When working with others I often want to point out a line I'm
    looking at in a file we already have in github. I'd like to be
    able to get the link rather than doing some sort of
    paste/gist/refheap.

    #+BEGIN_SRC emacs-lisp
      (use-package github-browse-file
        :ensure t)
    #+END_SRC

*** git-messenger

    Get the commit information for the current line. A bit like a mini
    git blame.

    #+BEGIN_SRC emacs-lisp
      (use-package git-messenger
        :ensure t)
    #+END_SRC

*** Github Flavouring

    I pretty much *always* want to do [[http://github.github.com/github-flavored-markdown/][github flavoured markdown]], so
    let's just change that auto-mode-alist.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'auto-mode-alist '(".md$" . gfm-mode))
    #+END_SRC

**** Github Flavoured Preview

     We also need to change the preview as the standard preview
     doesn't render github flavoured markdown correctly. I've
     installed markdown Preview+ as a Chrome Extension and associated
     .md files with Chrome on Mac OS X.

     This is all a bit broken really, but will work for now. I'm sorry
     that it is like this and I'm sure some day I'll fix it. This also
     means that you use markdown-open rather than markdown-preview.

     #+BEGIN_SRC emacs-lisp
       (setq markdown-open-command "open")
     #+END_SRC

*** Conventional Commits

    Add in a mode to do conventional commit messages.

    #+begin_src emacs-lisp :tangle yes
      (use-package conventional-commit
        :vc (conventional-commit :url "https://github.com/akirak/conventional-commit.el.git"
                                 :branch "master")
        :hook
        (git-commit-mode . conventional-commit-setup))
    #+end_src

** backup directories

   I'm fed up of having to put *~ into my .gitignore everywhere and
   I shouldn't really leave emacs only things in there anyway. Let's
   just move all the backup files to one directory.

   #+BEGIN_SRC emacs-lisp
     (setq
      backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '(("." . "~/.saves"))    ; don't litter my fs tree
      auto-save-file-name-transforms
      '((".*" "~/.saves"))
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      version-control t)       ; use versioned backups
   #+END_SRC

** Which key

   Use which key to show available key presses in minibuffer.

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :ensure t
       :config
       (which-key-mode)
       (setq which-key-popup-type 'minibuffer))
   #+END_SRC

** projectile

   [[https://github.com/bbatsov/projectile][projectile]] from [[http://twtitter.com/bbatsov][Bozhidar Batsov]] constrains and helps things like
   searches so that they happen within a git repo or leiningen
   project.

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :ensure t
       :config
       (projectile-global-mode)
       (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))

   #+END_SRC

   But we don't need to see that projectile mode is running everywhere
   so let's diminish it.

   #+BEGIN_SRC emacs-lisp
     (diminish 'projectile-mode)
   #+END_SRC

   Configure a gradlew project type to find test files on assumption
   it's a Java project.

   #+BEGIN_SRC emacs-lisp
     (projectile-register-project-type 'gradlew '("gradlew")
                                       :project-file "gradlew"
                                       :compile "./gradlew build"
                                       :test "./gradlew clean test"
                                       :test-suffix "Test")
   #+END_SRC

*** projectile indexing

    Set alien indexing for projectile

    #+BEGIN_SRC emacs-lisp
      (setq projectile-indexing-method 'alien)
    #+END_SRC

*** Consult projectile

    Use projectile from Consult

    #+begin_src emacs-lisp
      (use-package consult-projectile
        :ensure t)
    #+end_src

** perspective

   Add perspective mode.

   #+BEGIN_SRC emacs-lisp
     (use-package perspective
       :ensure t
       :init
       (customize-set-variable 'persp-mode-prefix-key (kbd "C-c M-p"))
       :config
       (persp-mode))
     (use-package persp-projectile
       :ensure t
       :defer t
       :config
       (customize-set-variable 'persp-mode-prefix-key (kbd "C-c M-p")))
   #+END_SRC

** Ag

   Add in ag package

   #+begin_src emacs-lisp
     (use-package ag
       :ensure t)
   #+end_src

** Ripgrep

   Add in ripgrep package

   #+begin_src emacs-lisp
     (use-package rg
       :ensure t)
   #+end_src

** Winnow mode

   Add winnow mode to help filter results.

   #+begin_src emacs-lisp
     (use-package winnow
       :ensure t
       :hook
       (ag-mode . winnow-mode)
       (rg-mode . winnow-mode)
       (compilation-mode . winnow-mode))
   #+end_src

** Jump to top or bottom of window

   Set up move-to-window-line 0 and move-to-window-line -

   #+BEGIN_SRC emacs-lisp
     (defun top-of-window ()
       (interactive)
       (move-to-window-line 0))
     (global-set-key (kbd "C-s-h") 'top-of-window)
     (defun bottom-of-window ()
       (interactive)
       (move-to-window-line -1))
     (global-set-key (kbd "C-s-l") 'bottom-of-window)
   #+END_SRC

** Crux

   Useful editing tools.

   #+BEGIN_SRC emacs-lisp
     (use-package crux
       :ensure t
       :init
       (global-set-key (kbd "C-x C-u") 'crux-upcase-region)
       (global-set-key (kbd "C-x C-l") 'crux-downcase-region)
       (global-set-key (kbd "s-r") 'crux-recentf-find-file)
       (global-set-key (kbd "C-c M-k") 'crux-kill-other-buffers)
       (global-set-key (kbd "C-c P") 'crux-kill-buffer-truename)
       (global-set-key (kbd "C-k") 'crux-smart-kill-line))
   #+END_SRC

** Revert buffer shortcut key

   Define a key chord for revert-buffer.

   #+begin_src emacs-lisp
     (define-key global-map (kbd "s-u") 'revert-buffer)
   #+end_src

* Text Modes

** Markdown mode

   Markdown mode used for viewing markdown formatted text.

   #+begin_src emacs-lisp
     (use-package markdown-mode
       :ensure t
       :mode ("README\\.md\\'" . gfm-mode)
       :init (setq markdown-command "multimarkdown"))
   #+end_src

** html, yaml, xml
*** Yaml

    #+BEGIN_SRC emacs-lisp
      (use-package yaml-mode
        :ensure t)
    #+END_SRC

*** css

    Think I need to give this some more sugar sometime....

**** rainbow mode

     And I want to see the colours I'm using.

     #+BEGIN_SRC emacs-lisp
       (add-hook 'css-mode-hook 'rainbow-mode)
     #+END_SRC



** Org mode customisation

*** Adapt indentation

    Adapt indentation to outline node level.

    #+BEGIN_SRC emacs-lisp
      (setq org-adapt-indentation t)
    #+END_SRC

*** Hide emphasis markers

    This hides the markup markers for *bold*, /italic/, etc.

    #+BEGIN_SRC emacs-lisp
      (setq org-hide-emphasis-markers t)
    #+END_SRC

*** Scale heading fonts

    #+BEGIN_SRC emacs-lisp
      (dolist (face '((org-level-1 . 1.2)
                      (org-level-2 . 1.1)
                      (org-level-3 . 1.05)
                      (org-level-4 . 1.0)
                      (org-level-5 . 1.1)
                      (org-level-6 . 1.1)
                      (org-level-7 . 1.1)
                      (org-level-8 . 1.1)))
        (set-face-attribute (car face) nil :weight 'regular :height(cdr face)))
    #+END_SRC

*** fontify

    This is all written in org-mode. It would be good if the source
    code examples were fonitfies according to their major mode.

    #+BEGIN_SRC emacs-lisp
      (setq org-src-fontify-natively t)
    #+END_SRC

*** spelling

    Switch on Flyspell for org-mode

    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-mode-hook 'turn-on-flyspell)
    #+END_SRC

*** org and magit

    Because sometimes you want to link to that particular commit.

    I added this functionality with this commit: [[orgit-rev:~/emacs-bankruptcy/::b14b9c37e7a9e43eba34aad4c9a3e31b4851d377][b14b9c3]]

    #+BEGIN_SRC emacs-lisp
      (use-package orgit
        :ensure t
        :after (magit org))
    #+END_SRC

*** ox-reveal

    [[https://github.com/hakimel/reveal.js/][reveal.js]] is a great way of making pretty presentations,
    especially if you have a fair bit of code. Kris Jenkins suggested
    that [[https://github.com/yjwen/org-reveal][ox-reveal]] would be a great way of generating the slides for
    reveal.js.

    #+BEGIN_SRC emacs-lisp
      (use-package ox-reveal
        :ensure t)
    #+END_SRC

*** Org bullets

    Make org mode bullets look a bit more like bullets and less like
    asterisks.

    #+BEGIN_SRC emacs-lisp
      (use-package org-bullets
        :ensure t)
      (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
    #+END_SRC

*** Load markdown backend ox-md

    Load the md backend for org-mode so that I can export to markdown.

    #+BEGIN_SRC emacs-lisp
      (require 'ox-md)
    #+END_SRC

*** Org auto tangle

    Automatically tangle org files to create any source file from the
    org file. Need to add org header ##+auto_tangle: t' to activate this.

    #+BEGIN_SRC emacs-lisp
      (use-package org-auto-tangle
        :ensure t
        :hook
        (org-mode . org-auto-tangle-mode))
    #+END_SRC

*** HTTP org babel

    #+BEGIN_SRC emacs-lisp
      (use-package ob-http
        :ensure t)
    #+END_SRC

*** Babel mode language load

    #+BEGIN_SRC emacs-lisp
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((R . t)
         (emacs-lisp . t)
         (shell . t)
         (clojure . t)
         (http . t)
         (java . t)
         (sql . t)
         ))
      (setq org-babel-clojure-backend 'cider)
    #+END_SRC

*** Activate Appointment Mode

    And now that we have our ical stuff in our diary we'll want
    notifications inside emacs too as we don't have gmail and google
    calendar open all the time.

    #+BEGIN_SRC emacs-lisp
      (appt-activate 1)
    #+END_SRC

*** Scheduling, Project Management, Time Keeping

**** todo keywords

     I seem to have come to some conclusions about which todo keywords
     actually work for me. The config below doesn't quite work yet
     though, so I'm still using per file keywords.

     #+BEGIN_SRC emacs-lisp
       (setq org-todo-keywords
             '((sequence "TODO(t)" "DOING(g!)" "|" "DONE(d!)")
               (sequence "WAITING(w@/!)" "BLOCKED(b@/!)" "REVIEW(r@/!)" "PLAN(p@/!)" "BACKLOG(l!)" "DOING(g!)" "|" "COMPLETED(m!)" "CANCELLED(n@/!)")
                                               ;(sequence "PROJECT(p!)" "|" "COMPLETE(m!)")
               (sequence "|"  "CANCELLED(n@/!)" "PHONE" "MEETING" "DECISION" "NOTE" "EMAIL")))
     #+END_SRC

**** Log when things are done

     I quite like to see in the agenda log when I've done things and
     I'd like to be prompted for a note as well.

     #+BEGIN_SRC emacs-lisp
       (setq org-agenda-start-with-log-mode t)
       (setq org-log-done 'note)
     #+END_SRC

**** Agenda

***** org-mode and Google Calendar with org-gcal

      Instead of importing google calendar events using a shell script
      and diary mode can we get gcal events into org-mode?

      org-gcal-file-alist, org-gcal-client-id and
      org-gcal-client-secret are all set in [[../local/mellon.el.gpg][mellon.el.gpg]].

      #+BEGIN_SRC emacs-lisp
        (use-package org-gcal
          :ensure t)
      #+END_SRC

***** Agenda Windows

      I'm not quite sure what possessed the org-mode people to
      presume that they knew best about how my windows should be
      arranged when I look at an agenda. There is a solution to that
      though. Just use the current window, like every other command
      that opens something up. Re-arrange frame indeed.

      #+BEGIN_SRC emacs-lisp
        (setq org-agenda-window-setup 'current-window)
      #+END_SRC

***** Agenda Files

      There are things for me and mine. Things I do for money. Things
      I do for the community I'm in. Let me know if you think my
      worldview is too small.

      And somethings we need in the agenda even though we don't know
      where to file it yet which is why refile is in here.

      #+BEGIN_SRC emacs-lisp
        (setq org-agenda-files '("~/org/notes.org" "~/org/personal.org" "~/org/gmail-schedule.org"))
      #+END_SRC

***** Agenda Sorting

      I want to sort my tasks in the agenda by the deadline, then
      schedule and then priority.

      Todo items I want to sort by deadline, schedule and then
      priority, but I usually filter out the things with deadline and
      schedule time in most agenda views.

      Tags and search are the same as the default values.

      #+BEGIN_SRC emacs-lisp
        (setq org-agenda-sorting-strategy
              '((agenda time-up
                        timestamp-up
                        priority-down
                        habit-down
                        category-keep)
                (todo priority-down
                      category-keep
                      todo-state-up
                      tag-up
                      effort-down)
                (tags priority-down
                      category-keep)
                (search category-keep)))
      #+END_SRC

***** Custom Agendas

      The real power of org-agenda starts to kick in when you create
      your own custom agenda commands that get the things *you* want
      out of your org files.

****** What am I doing in the Week Countdown?

       My default view, as I mostly use org for keeping my working
       days in line is around the Current Week Countdown.

       This is a composite agenda view that shows the agenda by date
       at the top and the todo list below that.

       The agenda spans one week and starts on a Monday (weekday
       1).

       It filters the todo list is a pretty bad way as I was having
       quite a bit of trouble with some of the regular expressions. I
       do have it so that it finds the DOING, WAITING and BLOCKED
       tasks and skips the DONE ones so that my view isn't too
       cluttered as I try to find the next task.

       It is also skips todo items that have a deadline or are
       scheduled as I have them already in the agenda at the top. It
       also overrides the text that describes the todo list. By
       default it is the regular expression we are using to filter the
       todo list.

       I also remove items that are scheduled or with deadlines from
       the weekly agenda when they are done. This is so I can keep the
       clutter down in this view and decide on what I want my next
       step to be.

       The todo items are also filtered to only show things that have
       the Owner property set to my name.

       #+BEGIN_SRC emacs-lisp
         (setq org-agenda-custom-commands
               '(("Cm" "My Week Countdown"
                  ((agenda "My Week Countdown"
                           ((org-agenda-span 'week)
                            (org-agenda-start-on-weekday 1)
                            (org-agenda-skip-deadline-if-done t)
                            (org-agenda-skip-scheduled-if-done t)))
                   (tags-todo "TODO={^[DCWBT].+[^E]$}+Owner=\"Chris\""
                              ((org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))
                               (org-agenda-overriding-header "My tasks for the Current Week Countdown: ")))))
                 ("Cw" "Workflow Status"
                  ((todo "WAITING"
                         ((org-agenda-overriding-header "Waiting on External")
                          (org-agenda-files org-agenda-files)))
                   (todo "REVIEW"
                         ((org-agenda-overriding-header "In Review")
                          (org-agenda-files org-agenda-files)))
                   (todo "PLAN"
                         ((org-agenda-overriding-header "In Planning")
                          (org-agenda-todo-list-sublevels nil)
                          (org-agenda-files org-agenda-files)))
                   (todo "BACKLOG"
                         ((org-agenda-overriding-header "Backlog")
                          (org-agenda-todo-list-sublevels nil)
                          (org-agenda-files org-agenda-files)))
                   (todo "DOING"
                         ((org-agenda-overriding-header "Active")
                          (org-agenda-files org-agenda-files)))
                   (todo "COMPLETED"
                         ((org-agenda-overriding-header "Completed")
                          (org-agenda-files org-agenda-files)))
                   (todo "CANCELLED"
                         ((org-agenda-overriding-header "Cancelled")
                          (org-agenda-files org-agenda-files)))))
                 ))
       #+END_SRC

****** My Window

       I need to know what I was doing on the last working day and I'd
       like to know what is coming up in the next 7 days.

       #+BEGIN_SRC emacs-lisp
         (add-to-list
          'org-agenda-custom-commands
          '("Cn" "My Window"
            ((agenda "My Window"
                     ((org-agenda-span 10)
                      (org-agenda-start-day "-3d")
                      (org-agenda-skip-deadline-if-done t)
                      (org-agenda-skip-scheduled-if-done t)))
             (tags-todo "TODO={^[DCWBT].+[^E]$}+Owner=\"Chris\""
                        ((org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))
                         (org-agenda-overriding-header "My window."))))))
       #+END_SRC

****** org-agenda hotkey

       #+BEGIN_SRC emacs-lisp
         (global-set-key (kbd "C-c a") 'org-agenda)
       #+END_SRC

**** Time Tracking and Estimates

     org-mode is huge. It does so much, but my reason for using it
     was so that I could track effort vs estimates. It makes me
     happier than a burn down chart, but probably just because I'm
     writing elisp to do it rather than excel or google docs. This
     hack works on my mind, but YMMV.

***** clocking in, out and persistence

      It is true, emacs crashes, I forget to clock out, there is just
      life, ok? So, when we clock in to a new task we'll be prompted
      to complete the time for the old task. Just to keep things
      straight.

      There is more about measuring idle time in the org-mode docs
      [[http://orgmode.org/manual/Resolving-idle-time.html][here]].

      #+BEGIN_SRC emacs-lisp
        (setq org-clock-persist 'history)
        (org-clock-persistence-insinuate)
      #+END_SRC

***** Tracking effort vs estimates with clocksum

      I think of days as being working days rather than groups of 24
      hours (I'm damaged, what can I say). So I want to see sums of
      times always in hours rather than as days. Otherwise I just get
      confused and wonder why spending three eight hour days working on
      something gets summed up as just one day.

      I found out about this bit of configuration on [[http://stackoverflow.com/questions/17929979/emacs-org-mode-how-to-stop-total-in-column-view-showing-number-of-days][Stack Overflow]].

      This is really handy when looking at things in column mode in
      org. I use column mode as an alternative to burn down charts to
      track effort vs estimates.

      #+BEGIN_SRC emacs-lisp
        (setq org-time-clocksum-format
              '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))
      #+END_SRC

**** Put those logs in a drawer

     It may be big and heavy and wood, but mostly I don't want to see
     log messages for state change.

     #+BEGIN_SRC emacs-lisp
       (setq org-log-into-drawer t)
     #+END_SRC

     We also want to put the clocking in and out into the drawer.

     #+BEGIN_SRC emacs-lisp
       (setq org-clock-into-drawer t)
     #+END_SRC

**** You can depend on...

     The sub tasks that are underneath the main task.

     #+BEGIN_SRC emacs-lisp
       (setq org-enforce-todo-dependencies t)
     #+END_SRC

*** Capturing, Templates and Refiling

**** Default Notes File

     I don't want to think about things when I'm just capturing
     them. I can refile them later.

     #+BEGIN_SRC emacs-lisp
       (setq org-default-notes-file (concat org-directory "/notes.org"))
     #+END_SRC

**** Capture Hot Key

     Let's capture things with a quick Vulcan Nerve Pinch on
     C-c o.

     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "C-c o") 'org-capture)
     #+END_SRC

**** Capture Templates

     To do, respond, notes, journals, meetings and phone calls. These
     are the things we want to keep track of and clock in and out of
     let's see how we get on with them.

     We also have a way of tracking things we are doing RFN as well
     as capturing things for the future.

     #+BEGIN_SRC emacs-lisp
       (setq org-capture-templates
             '(("c" "Contacts" entry (file "~/org/contacts.org")
                "* %(org-contacts-template-name)\n:PROPERTIES:\n:EMAIL: %(org-contacts-template-email)\n:PHONE:\n:ALIAS:\n:NICKNAME:\n:IGNORE:\n:ICON:\n:NOTE:\n:ADDRESS:\n:BIRTHDAY:\n:LAST_READ_MAIL:\n:END:" :empty-lines-after 1)
               ("t" "Doing RIGHT NOW" entry (file+datetree org-default-notes-file)
                "* DOING %?\n%n\n%U\n%a\n" :clock-in t :clock-resume t :empty-lines-after 1)
               ("f" "Do in the Future" entry (file+datetree org-default-notes-file)
                "* TODO %?\n%^{Owner}p\n%U\n%a\n" :empty-lines-after 1)
               ("r" "respond" entry (file+datetree org-default-notes-file)
                "* TODO Respond to %:from on %:subject\nSCHEDULED: %t\n%^{Owner}p\n%U\n%a\n"
                :clock-in t :clock-resume t :empty-lines-after 1)
               ("n" "note" entry (file+datetree org-default-notes-file)
                "* %? :NOTE:\n%U\n%a\n" :clock-resume t :empty-lines-after 1)
               ("j" "Journal" entry (file+datetree org-default-notes-file)
                "* %?\n%U\n" :clock-in t :clock-resume t :empty-lines-after 1 :empty-lines-after 1)
               ("m" "Meeting" entry (file+datetree org-default-notes-file)
                "* MEETING with %? :MEETING:\n%^{Owner}p\n%U" :clock-in t :clock-resume t :empty-lines-after 1)
               ("p" "Phone call" entry (file+datetree org-default-notes-file)
                "* PHONE %? :PHONE:\n%^{Owner}p\n%U" :clock-in t :clock-resume t :empty-lines-after 1)))
     #+END_SRC

**** Refiling rules

     We want to be able to refile things in to an archive file
     and in files that we create our agenda from.

     #+BEGIN_SRC emacs-lisp
       (setq org-refile-targets
             '((nil :maxlevel . 9)
               (org-agenda-files :maxlevel . 9)
               ("~/org/refile.org" :maxlevel . 9)))
       (advice-add 'org-refile :after 'org-save-all-org-buffers)
     #+END_SRC

*** org and the pomodoro technique

    When I need to just grind through something or find a way to keep
    myself focused when I'm having trouble I like to use the
    [[http://www.pomodorotechnique.com/][pomodoro technique]]. Luckily there is org-pomodoro that let's us
    put these two great things together.

    #+BEGIN_SRC emacs-lisp
      (use-package org-pomodoro
        :ensure t)
      (add-hook 'org-mode-hook
                (lambda () (local-set-key (kbd "M-s-p") 'org-pomodoro)))
    #+END_SRC

**** A hotkey in Org Agenda

     I can clock in and out in Org Agendas, I'd like to be able to
     start Pomodoros as well.

     #+BEGIN_SRC emacs-lisp
       (add-hook 'org-agenda-mode-hook
                 (lambda () (local-set-key (kbd "P") 'org-pomodoro)))
     #+END_SRC

*** redtick for pomodoro

    Bruce recommended redtick for pomodoro's outside of org mode so
    going to give it a go.

    #+BEGIN_SRC emacs-lisp
      (use-package redtick :ensure t)
    #+END_SRC


** Org faces

   Require org-faces.

   #+BEGIN_SRC emacs-lisp
     (require 'org-faces)
   #+END_SRC

* Programming Modes
** shell
   
   #+BEGIN_SRC emacs-lisp
     (global-set-key [C-M-return] 'shell)
     ;; Use bash explicitly cos fancy shells like zsh don't render well in emacs
     (setq explicit-shell-file-name "/bin/zsh")
     (setq shell-file-name "zsh")
     (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
     (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
   #+END_SRC

** restclient

   Added in rest client to allow for manual testing of restful client.

   #+BEGIN_SRC emacs-lisp
     (use-package restclient
       :ensure t)
     (use-package restclient-jq
       :ensure t
       :hook (restclient . restclient-jq))

   #+END_SRC

** prog-mode

   prog-mode and the prog-mode-hook are at the basis of most of the
   programming modes in emacs. If we want something set up for
   everything we should do it here.

*** Parentheses
**** Show Them

     We really want to see those parentheses.

     #+BEGIN_SRC emacs-lisp
       (show-paren-mode +1)
     #+END_SRC

*** rainbow-delimiters

    Make those delimiters glow with wacky colors so we can see what is
    going on.

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-delimiters
        :ensure t
        :hook
        (prog-mode . rainbow-delimiters-mode)
        (org-mode . rainbow-delimiters-mode))
    #+END_SRC

*** flycheck

    Flycheck should give on the fly syntax checking.

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck :ensure t)

    #+END_SRC

*** rainbow mode

    If we have a color literal it is really nice to have an idea of
    what it is going to look like. This is *really* useful in things
    like editing CSS files with hex color codes.

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-mode
        :ensure t)
      (add-hook 'prog-mode-hook 'rainbow-mode)
      (diminish 'rainbow-mode)
    #+END_SRC
    ***
*** highlight-symbol

    I like to see all of the places I'm using the same symbol. This is
    a great visual cue for those times where you've mistyped a variable
    for function name. It isn't quite flymake, but it is handy. It is
    good to see where something is used as well.

    #+BEGIN_SRC emacs-lisp
      (use-package highlight-symbol
        :ensure t)
      (add-hook 'prog-mode-hook 'highlight-symbol-mode)
      (setq highlight-symbol-on-navigation-p t)
      (global-set-key [f3] 'highlight-symbol-next)
      (global-set-key [(shift f3)] 'highlight-symbol-prev)
    #+END_SRC


*** yasnippet

    Yasnippets to add snippets and snippets completion.

    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet :ensure t)
      (key-chord-define-global "yy" 'yas-expand-from-trigger-key)
      (define-key yas-minor-mode-map (kbd "C-c C-y") 'yas-visit-snippet-file)
      (define-key yas-minor-mode-map (kbd "C-c y") 'company-yasnippet)
    #+END_SRC

**** yasnippet-snippets

     Set up yasnippet-snippets from Andrea (awesome guy that he is he's saved me loads of time here).

     #+BEGIN_SRC emacs-lisp
       (use-package yasnippet-snippets
         :ensure t)
     #+END_SRC

**** Turn it on globally

     And we want to add yasnippets to all modes where we have snippets.

     #+BEGIN_SRC emacs-lisp
       (yas-global-mode 1)
     #+END_SRC

**** Diminish it

     I don't need to see it everywhere though.

     #+BEGIN_SRC emacs-lisp
       (diminish 'yas-minor-mode)
     #+END_SRC

**** Java snippets

     #+BEGIN_SRC emacs-lisp
       (use-package java-snippets
         :ensure t)
     #+END_SRC


**** react snippets

     #+begin_src emacs-lisp
       (use-package js-react-redux-yasnippets
         :ensure t)
     #+end_src

*** smartscan

    A suggestion from [[http://www.masteringemacs.org/articles/2011/01/14/effective-editing-movement/][Effective Editing]] in [[http://www.masteringemacs.org/][Mastering Emacs]]. This
    allows you to go to the next identifier like the one you are
    currently on by using M-n and M-p.

    #+BEGIN_SRC emacs-lisp
      (use-package smartscan :ensure t
        :hook
        (prog-mode . smartscan-mode)
        (org-mode . smartscan-mode))
      (add-hook 'prog-mode-hook
                '(lambda () (smartscan-mode 1)))
    #+END_SRC

*** Set line numbers mode in prog modes

    Set line numbers on in all programming modes.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'prog-mode-hook 'display-line-numbers-mode)
    #+END_SRC


*** Set font for prog modes

    Set the font for all prog modes.

    #+BEGIN_SRC emacs-lisp
      (defun my-buffer-face-mode-variable ()
        "Set font to a variable width (proportional) fonts in current buffer"
        (interactive)
        (setq buffer-face-mode-face '(:family "IosevkaAile"))
        (buffer-face-mode))

      ;; Use monospaced font faces in current buffer
      (defun my-buffer-face-mode-fixed ()
        "Sets a fixed width (monospace) font in current buffer"
        (interactive)
        (setq buffer-face-mode-face
              '(:family "JetBrains Mono"))
        (buffer-face-mode))

      (add-hook 'prog-mode-hook 'my-buffer-face-mode-fixed)
    #+END_SRC

** lisp modes

   emacs-lisp and clojure are the two that really go in here for now,
   though in the future scheme and common lisp could be added.

*** lisp hooks

    These are the common lisp hooks we want shared across all lisp
    modes.

    #+BEGIN_SRC emacs-lisp
      (setq lisp-hooks (lambda ()
                         (eldoc-mode +1)
                         (diminish 'eldoc-mode)
                         (define-key paredit-mode-map
                                     (kbd "{") 'paredit-open-curly)
                         (define-key paredit-mode-map
                                     (kbd "}") 'paredit-close-curly)
                         (local-set-key (kbd "C-;") 'comment-dwim)))
    #+END_SRC

*** emacs-lisp

**** lisp-mode-hook

     Let's add the lisp mode hook to the emacs-lisp-mode

     #+BEGIN_SRC emacs-lisp
       (add-hook 'emacs-lisp-mode-hook lisp-hooks)
     #+END_SRC

**** Pop Up Help in Emacs Lisp
     DEADLINE: <2024-07-11 Thu>

     Thx again to [[http://twitter.com/krisajenkins][Kris Jenkins]] and his [[http://blog.jenkster.com/2013/12/popup-help-in-emacs-lisp.html][blog post]] I've got even yet
     more help with emacs-lisp functions in a popup just like in ac
     stuff in clojure modes. Thanks to [[http://twitter.com/sanityinc][Steve Purcell]] we have an
     improved version that gets faces and vars in addition to
     functions, so in some ways it is even a bit better than what is
     available in cider/clojure-mode (from my understanding anyway).

     #+BEGIN_SRC emacs-lisp
       (require 'popup)

       (defun describe-thing-in-popup ()
         (interactive)
         (let* ((thing (symbol-at-point))
                (help-xref-following t)
                (description (with-temp-buffer
                               (help-mode)
                               (help-xref-interned thing)
                               (buffer-string))))
           (popup-tip description
                      :point (point)
                      :around t
                      :height 30
                      :scroll-bar t
                      :margin t)))
     #+END_SRC


***** The usual help keybinding

      Let's use C-c C-d for describing functions at point as this is
      the binding in cider/nrepl that I'm used to. We'll probably do
      this in other modes as well so we'll make it a local keybinding
      and then it will more or less [[http://en.wikipedia.org/wiki/DWIM][dwim]].
      Let's use C-c C-k (like cider does) to run eval buffer in
      emacs-lisp mode.


      #+BEGIN_SRC emacs-lisp
        (add-hook 'emacs-lisp-mode-hook
                  (lambda () (local-set-key (kbd "C-c C-d") 'describe-thing-in-popup)
                    (local-set-key (kbd "C-c C-k") 'eval-buffer)))
      #+END_SRC


***** Help binding for org-mode (as C-c C-d is used for org-deadline)

      Let's use C-c d for describing functions at point in org-mode (for embedded code).

      #+begin_src emacs-lisp :tangle yes
        (add-hook 'org-mode-hook
                  (lambda () (local-set-key (kbd "C-c d") 'describe-thing-in-popup)))
      #+end_src

*** auto complete bash style in shell

    I found the autocompletion for shell wasn't working properly
    and didn't work like bash

    #+BEGIN_SRC emacs-lisp
      (use-package bash-completion
        :ensure t
        :config (bash-completion-setup))
    #+END_SRC

*** clojure

    I do *love* coding in clojure. The tool chain has been evolving
    quite a bit over the last few years.

    Everything has gone from being built only with maven to maven
    being just for core and everything else being done with [[http://leiningen.org/][Leiningen]].

    On the emacs side we've gone from the swank and slime, to nrepl
    and nrepl.el, to now we have nrepl and cider.el. Trying to move to
    cider.el is what caused me to declare .emacs.d bankruptcy this
    time and restructure everything.

    Most of the clojure emacs goodness if available in the github
    repo called [[https://github.com/clojure-emacs][clojure-emacs]].
**** boot
***** treat .boot files as clojure source

      #+BEGIN_SRC emacs-lisp
        (add-to-list 'auto-mode-alist '("\\.boot\\'" . clojure-mode))
      #+END_SRC

***** treat boot scripts files as clojure

      #+BEGIN_SRC emacs-lisp
        (add-to-list 'magic-mode-alist '(".* boot" . clojure-mode))
      #+END_SRC

**** cider

***** install

      You can get most of the clojure support by just elpa installing
      cider.

      #+BEGIN_SRC emacs-lisp
        (use-package cider
          :ensure t
          :pin melpa-stable)
        (diminish 'cider-mode "Cλ")
      #+END_SRC

***** clojure-mode-hook

      We'll also want to get our lisp-hooks into our clojurey
      goodness. It would be a shame to not have it here.

      #+BEGIN_SRC emacs-lisp
        (add-hook 'clojure-mode-hook lisp-hooks)
        (setq clojure-toplevel-inside-comment-form nil)
      #+END_SRC

***** Save cider history

      We also want to save the history of our interactions. There might
      be gold there.

      #+BEGIN_SRC emacs-lisp
        (setq cider-repl-history-file (concat user-emacs-directory "cider-history"))
      #+END_SRC

***** subword-mode

      I also want to be able to navigate to the "-" characters in words.

      #+BEGIN_SRC emacs-lisp
        (add-hook 'cider-mode-hook 'subword-mode)
        (add-hook 'cider-mode-hook (lambda () (setq lsp-enable-completion-at-point nil)))
      #+END_SRC

***** Don't destroy that repl buffer while pretty printing

      It can be very frustrating to be poking away at clojure data
      structures in the repl and then accidentally print a big, or
      worse and infinite sequence. This should stop that.

      #+BEGIN_SRC emacs-lisp
        (setq cider-print-options '(("length" 1000)))
      #+END_SRC

      And seeing as we are limiting what we print, we should pretty
      print by default.

      #+BEGIN_SRC emacs-lisp
        (setq cider-repl-use-pretty-printing t)
      #+END_SRC

***** Customisations in CIDER

      Supress auto-display of the REPL buffer in separate window and
      make 'C-c C-z' switch to the CIDER REPL in the current window

      #+BEGIN_SRC emacs-lisp
        (setq cider-repl-pop-to-buffer-on-connect nil)
        (setq cider-repl-display-in-current-window t)
      #+END_SRC

***** Start figwheel-sidecar shortcuts

      From the Using Figwheel REPL within nREPL page.

      #+BEGIN_SRC emacs-lisp
        (defun cider-figwheel-repl ()
          (interactive)
          (save-some-buffers)
          (with-current-buffer (cider-current-repl-buffer)
            (goto-char (point-max))
            (insert
             "(require 'figwheel-sidecar.repl-api)
                 (do (figwheel-sidecar.repl-api/start-figwheel!) nil) ; idempotent
                     (figwheel-sidecar.repl-api/cljs-repl)")
            (cider-repl-return)))
        (add-hook 'cider-repl-mode-hook
                  (lambda () (local-set-key (kbd "C-c C-f") 'cider-figwheel-repl)))
      #+END_SRC

***** A few repl tweaks

      I want paredit, rainbow delimiters and clojure-mode highlighting
      in my repl buffer.

      #+BEGIN_SRC emacs-lisp
        (add-hook 'cider-repl-mode-hook #'paredit-mode)
        (add-hook 'cider-repl-mode-hook
                  (lambda () (local-set-key (kbd "<return>") 'cider-repl-return)))
        (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)
        (add-hook 'cider-repl-mode-hook #'eldoc-mode)
      #+END_SRC

**** REBL repl

     #+BEGIN_SRC emacs-lisp
       ;; Similar to C-x C-e, but sends to REBL
       (defun rebl-eval-last-sexp ()
         (interactive)
         (let* ((bounds (cider-last-sexp 'bounds))
                (s (cider-last-sexp))
                (reblized (concat "(cognitect.rebl/inspect " s ")")))
           (cider-interactive-eval reblized nil bounds (cider--nrepl-print-request-map))))

       ;; Similar to C-M-x, but sends to REBL
       (defun rebl-eval-defun-at-point ()
         (interactive)
         (let* ((bounds (cider-defun-at-point 'bounds))
                (s (cider-defun-at-point))
                (reblized (concat "(cognitect.rebl/inspect " s ")")))
           (cider-interactive-eval reblized nil bounds (cider--nrepl-print-request-map))))

       ;; C-S-x send defun to rebl
       ;; C-x C-r send last sexp to rebl (Normally bound to "find-file-read-only"... Who actually uses that though?)
       (add-hook 'cider-mode-hook
                 (lambda ()
                   (local-set-key (kbd "C-S-x") #'rebl-eval-defun-at-point)
                   (local-set-key (kbd "C-x M-r") #'rebl-eval-last-sexp)))
     #+END_SRC

**** clj-refactor

     Lots of cool little time savers in here.

     #+BEGIN_SRC emacs-lisp
       (use-package clj-refactor
         :ensure t)
       (defun my-clojure-mode-hook ()
         (clj-refactor-mode 1)
         (yas-minor-mode 1) ; for adding require/use/import statements
         (cljr-add-keybindings-with-prefix "C-c C-m")
         (setq cljr-favor-prefix-notation nil)
         (setq cljr-add-ns-to-blank-clj-files nil)
         (setq cljr-insert-newline-after-require nil)
         (setq lsp-ui-doc-enable nil))

       (add-hook
        'clojure-mode-hook #'my-clojure-mode-hook)
     #+END_SRC

**** clojurescript

     Get those cljs files building automatically and get the errors
     popping up in your emacs.

     #+BEGIN_SRC emacs-lisp
       (use-package cljsbuild-mode
         :ensure t)
     #+END_SRC

**** Clojure Cheat Sheet

     It was this helm addon from Kris Jenkins that made me start to
     look at helm. And having the clojure cheat sheet to hand is
     useful.

     I like binding cheatsheets to s-f9.
     cheatsheet is installed as part of CIDER 17 now

     #+BEGIN_SRC emacs-lisp
       (add-hook 'clojure-mode-hook
                 (lambda () (local-set-key [s-f9] 'clojure-view-cheatsheet)))
     #+END_SRC

**** Flycheck clojure

     Saw this mentioned in Bat's CIDER manual so thought I'd give it a
     shot

     #+BEGIN_SRC emacs-lisp
       (use-package flycheck-clojure
         :ensure t)
       (use-package flycheck-pos-tip
         :ensure t)
     #+END_SRC

**** Joker linting using flycheck-joker

     Make sure you have the joker executable on your path somewhere.

     #+BEGIN_SRC emacs-lisp
       (use-package flycheck-joker
         :ensure t)
     #+END_SRC

**** clj-kondo linting

     Make sure you have the clj-kondo executable on your path.

     #+BEGIN_SRC emacs-lisp
       (use-package flycheck-clj-kondo
         :ensure t)
       (dolist (checker '(clj-kondo-clj clj-kondo-cljs clj-kondo-cljc clj-kondo-edn))
         (setq flycheck-checkers (cons checker (delq checker flycheck-checkers))))
       (dolist (checkers '((clj-kondo-clj . clojure-joker)
                           (clj-kondo-cljs . clojurescript-joker)
                           (clj-kondo-cljc . clojure-joker)
                           (clj-kondo-edn . edn-joker)))
         (flycheck-add-next-checker (car checkers) (cons 'error (cdr checkers))))
     #+END_SRC

** JavaScript

*** js2 mode

    According to [[http://twitter.com/sw1nn][Neale Swinnerton]] js2-mode is the way to go.

    #+BEGIN_SRC emacs-lisp
      (use-package js2-mode
        :ensure t
        :config
        (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
        (add-to-list 'auto-mode-alist '("\\.mjs\\'" . js2-mode))
        ;; Better imenu
        (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
        (setq js2-basic-offset 2))
    #+END_SRC

    And we can hook it in to run node.js shell scripts as well.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'interpreter-mode-alist '("node" . js2-mode))
    #+END_SRC

*** Treesitter

    Colouring for JS and Typescript.

    #+begin_src emacs-lisp
      (use-package tree-sitter
        :ensure t
        :config
        ;; activate tree-sitter on any buffer containing code for which it has a parser available
        (global-tree-sitter-mode)
        ;; you can easily see the difference tree-sitter-hl-mode makes for python, ts or tsx
        ;; by switching on and off
        (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))

      (use-package tree-sitter-langs
        :ensure t
        :after tree-sitter)

      (setq treesit-language-source-alist
            '((bash "https://github.com/tree-sitter/tree-sitter-bash")
              (cmake "https://github.com/uyha/tree-sitter-cmake")
              (css "https://github.com/tree-sitter/tree-sitter-css")
              (elisp "https://github.com/Wilfred/tree-sitter-elisp")
              (go "https://github.com/tree-sitter/tree-sitter-go")
              (html "https://github.com/tree-sitter/tree-sitter-html")
              (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
              (json "https://github.com/tree-sitter/tree-sitter-json")
              (make "https://github.com/alemuller/tree-sitter-make")
              (markdown "https://github.com/ikatyang/tree-sitter-markdown")
              (python "https://github.com/tree-sitter/tree-sitter-python")
              (toml "https://github.com/tree-sitter/tree-sitter-toml")
              (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
              (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
              (yaml "https://github.com/ikatyang/tree-sitter-yaml")))

      (mapc #'treesit-install-language-grammar (mapcar #'car treesit-language-source-alist))
    #+end_src

** DAP - Debug Adapter Protocol

*** DAP mode config

    I use DAP mode for debugging.

    #+begin_src emacs-lisp
      (use-package dap-mode
        :ensure t
        :after lsp-mode
        :hook ((lsp-mode . dap-mode)
               (lsp-mode . dap-ui-mode)
               (lsp-mode . dap-ui-controls-mode))
        :config (dap-auto-configure-mode))
    #+end_src

** Typescript

*** Typescript mode

    #+BEGIN_SRC emacs-lisp

      (use-package typescript-mode
        :after tree-sitter
        :ensure t
        :config
        (setq typescript-indent-level 2)
        (electric-indent-mode nil))
    #+END_SRC

*** ts-comint repl for typescript

    Use ts-comint as a REPL for typescript.

    #+BEGIN_SRC emacs-lisp
      (use-package ts-comint
        :ensure t
        :bind (:map typescript-mode-map
               ("C-x C-e" . ts-send-last-sexp)
               ("C-M-x" . ts-send-last-sexp-and-go)
               ("C-c b" . ts-send-buffer)
               ("C-c C-b" . ts-send-buffer-and-go)
               ("C-c l" . ts-load-file-and-go)))
    #+END_SRC

** Jest Test mode

   Run Jest tests

   #+BEGIN_SRC emacs-lisp
       (use-package jest-test-mode
         :ensure t
         :commands jest-test-mode
         :hook (typescript-mode js2-mode typescript-tsx-mode))
   #+END_SRC

** pastebins

   gist, pastebin, refheap. All good ways of sharing snippets of code
   with people on irc or similar.

*** gist

    As you probably already have a github account, having gist as a
    way of sharing code snippets is a good idea.

    #+BEGIN_SRC emacs-lisp
      (use-package gist
        :ensure t)
    #+END_SRC

** Language Server Protocol

** Apheleia

    auto-format different source code files extremely intelligently
    https://github.com/radian-software/apheleia

    #+BEGIN_SRC emacs-lisp
      (use-package apheleia
        :ensure t
        :config
        (apheleia-global-mode +1))
    #+END_SRC


*** LSP config

    This is my set up for the Language Server Protocol.

    #+begin_src emacs-lisp
      (use-package lsp-mode
        :ensure t
        :init
        ;; set prefix for lsp-command-keymap - use meta-super-l ("M-s-l")
        (setq lsp-keymap-prefix "M-s-l")
        :hook (;;  concrete major-modes to use lsp (e. g. clojure-mode)
               (clojure-mode . lsp-deferred)
               (clojurec-mode . lsp-deferred)
               (clojurescript-mode . lsp-deferred)
               (js2-mode . lsp-deferred)
               (typescript-mode . lsp-deferred)
               (java-mode . lsp-deferred)
               ;; if you want which-key integration
               (lsp-mode . lsp-enable-which-key-integration)
               (lsp-mode . flycheck-mode)
               (lsp-mode . lsp-lens-mode))
        :commands lsp
        :config
        (setq lsp-ui-doc-show-with-cursor nil) ; Set to t if you want doc popup at cursor rather than mouse over
        (setq lsp-completion-enable t)
        (setq lsp-completion-mode t)
        (setq gc-cons-threshold 1000000)
        (setq read-process-output-max (* 1024 1024 2))
        (setq lsp-idle-delay 0.3))
    #+end_src

    Set up ui

    #+begin_src emacs-lisp
      (use-package lsp-ui
        :ensure t
        :commands lsp-ui-mode)
    #+end_src

    Add in consult support.

    #+begin_src emacs-lisp
      (use-package consult-lsp
        :ensure t
        :config
        (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols))
    #+end_src

*** LSP for Java

    Add in Java LSP and config for it and dap-java.

    #+begin_src emacs-lisp
      (use-package lsp-java
        :ensure t
        :after lsp-mode
        :config
        (require 'dap-java))
    #+end_src

    Bind debug Java keys after loading Java mode

    #+begin_src emacs-lisp
      (defun bind-java-dap-keys ()
        (define-key java-mode-map (kbd "M-s-l t t") 'dap-java-run-test-method)
        (define-key java-mode-map (kbd "M-s-l t d") 'dap-java-debug-test-method))
      (with-eval-after-load 'java-mode (bind-java-dap-keys))
    #+end_src
    

* Data Modes

* Multimedia

* Notification Systems

* Utilities and General Keybindings
** cleanup buffer

   Borrowed from Magnars gist https://github.com/magnars/.emacs.d/blob/master/defuns/buffer-defuns.el

   #+begin_src emacs-lisp
     (defun untabify-buffer ()
       (interactive)
       (untabify (point-min) (point-max)))

     (defun indent-buffer ()
       (interactive)
       (indent-region (point-min) (point-max)))

     (defun cleanup-buffer ()
       "Perform a bunch of operations on the whitespace content of a buffer.
        Including indent-buffer, which should not be called automatically on save."
       (interactive)
       (untabify-buffer)
       (delete-trailing-whitespace)
       (indent-buffer))
     (global-set-key (kbd "C-c n") 'cleanup-buffer)
   #+end_src

* Misc
** Add exec path from shell

   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
       :ensure t)
     (exec-path-from-shell-initialize)
   #+END_SRC
